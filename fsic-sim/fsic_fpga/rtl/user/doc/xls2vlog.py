#!/usr/bin/python3

import sys
import os
import re
import argparse

src_file=""
prt_modu=""

def print_banner(fh):
  from datetime import date
  today = date.today()

  global src_file

  print("// This code snippet was auto generated by xls2vlog.py from source file: " + src_file, file=fh)
  u_name = os.getlogin()
  print("// User: " + u_name, file=fh)
  td = today.strftime("%b-%d-%y")
  print("// Date: " + td +"\n", file=fh)


def get_upper_str(in_str):
  out_str="";
  for cc in in_str:
   if( (cc.isupper()) == True ):
#   print(cc)
    out_str += cc;
   else:
    if( cc == "_" or cc.isdigit() ):
     out_str += cc;
#   else:
#    print(cc)

# for i in range(0,len(in_str)):
#  if( in_str[i].isupper ):
#   out_str += in_str[i];

  # remove last '_'
  out_str = re.sub('_$', '', out_str)
# print("src string: " + in_str + ", compiled string: " + out_str)
  return(out_str)


def spaces(n):
  return ' ' * n


# each element in list will be src_port/dsc_port:width(top_wire_name)
# remove unnecessary space
def get_port_list_from_cell(port_str):
# port_str = str(cell.value)
  port_str = re.sub('\s+:',  ':',   port_str)  # change "  :" to ":"  leading
  port_str = re.sub(':\s+',  ':',   port_str)  # change ":  " to ":"  tailing

  port_str = re.sub('\s+/',  '/',   port_str)  # change "  /" to "/"  leading
  port_str = re.sub('/\s+',  '/',   port_str)  # change "/  " to "/"  tailing

  port_str = re.sub('\s+\(', '\(',  port_str)  # change "  (" to "("  leading
  port_str = re.sub('\(\s+', '\(',  port_str)  # change "(  " to "("  tailing

  port_str = re.sub('\s+\)', '\)',  port_str)  # change "  )" to ")"  leading
  port_str = re.sub('\)\s+', '\) ', port_str)  # change ")  " to ") " tailing

  #  use "," or " " as port list delimitor
  port_str = re.sub('\s+',  ',',  port_str)    # change all space to ","
  port_str = re.sub('[,]+', ',',  port_str)    # reduce many ",,," to singe ","
  port_str = re.sub(',$',   '',   port_str)    # remove last ,
  # print("ppp "+ port_str + " ppp")
  port_lst = port_str.split(",")
  return port_lst

# -------------------------------------------------------------------------------------------------------
# define a module's I/O port or Interface
class port:
  def __init__(self, port_name):
    self.name        = port_name      # interface's instance name if this port is an interface port
    self.wire_intf   = True           # flag, 1: "generic verilog port" or 0: "systemverilog interface"
    self.wid_is_num  = True           # flag, width is a number of a parameter text
    self.width       = 1 
    self.width_pname = "";
    self.intf_name   = ""             # AXI4.MASTER
    self.dir         = ""             # "input", "output", or "" for interface port
    self.conn_name   = ""             # inter-connection wire name  (external)

  def is_wire(self, dir):
    self.wire_intf   = True           # flag, 1: "generic verilog port" or 0: "systemverilog interface"
    self.intf_name   = ""             # AXI4.MASTER
    self.dir         = dir            # 0 is input, 1 is output, only for non-interface port
    

  def is_intf(self, intf_type):
    self.wire_intf   = False          # flag, 1: "generic verilog port" or 0: "systemverilog interface"
    self.wid_is_num  = False          # flag, width is a number of a parameter text
    self.width       = 0 
    self.intf_name   = intf_type      # AXI4.MASTER
    

  def set_width(self, port_width):
    if( self.wire_intf ):
      if( port_width.isnumeric() ):       # check width type (int or string)
        self.wid_is_num  = True           
        self.width = int(port_width)
      else:
        self.wid_is_num  = False           # flag, width is a "number" or a "parameter" text
        if( type(port_width) == str ):
          self.width_pname = port_width
          self.width = 0
        else:
          print("Error, Port width should be int or string only")
          sys.exit()
    else:
#     self.wire_intf   = False          # flag, 1: "generic verilog port" or 0: "systemverilog interface"
      print("Error, Interface port cannot set its width")
      sys.exit()

  # return a width string [x:0]
  def get_wid_str(self):
    if( self.wire_intf ):
      if( self.wid_is_num ):      # check width type (int or string)
        if( self.width < 2 ):
          wid_str = ""
        else:
          wid_str = "[" + str(self.width-1) + ": 0]"
        return(wid_str)
      else:
        wid_str = "[(" + self.width_pname + "-1) : 0]"
        return(wid_str)
    else:
      return("XXX")

  def get_wid_str_simple(self):
    if( self.wire_intf ):
      if( self.wid_is_num ):      # check width type (int or string)
        if( self.width < 2 ):
          wid_str = ""
        else:
          wid_str = str(self.width)
        return(wid_str)
      else:
        wid_str = self.width_pname
        return(wid_str)
    else:
      return("INTF")

  def set_conn_name(self, conn_name):
    self.conn_name = conn_name

  def upd_width(self, new_wid):   # only update width if new width is wider, new_wid should be numerical string
    if( self.wid_is_num ):  # check width type (int or string)
      if( self.width < int(new_wid) ):
        self.width = int(new_wid)
    else:
      print("Error, upd_width only support port with numerical width")
      sys.exit()




# def set_port_intf(intf_name):
#   if( self.wire_intf == False ):
#     self.self_intf_name = intf_name
#   else
#     print("Error, This is not an interface port")
  



# -------------------------------------------------------------------------------------------------------
# define a wire or interface that connect two modules
class conn(port):
  def __init__(self, conn_name):
    super().__init__(conn_name)

#   super().is_wire
#   self.name        = wire_name 
#   self.wid_is_num  = True           # flag, width is a number or a parameter text
#   self.width       = 1
#   self.width_pname = ""

  def set_conn_width(self, wire_width):
    super().is_wire("inout ")
    super().set_width(wire_width)

  def set_conn_intf(intf_type):
    super().is_intf(intf_type)

#   super().set_port_intf(intf_type)

#   if( type(wire_width) == int ):      # check width type (int or string)
#     self.wid_is_num  = True           
#     self.width = width
#   else:
#     self.wid_is_num  = False           # flag, width is a "number" or a "parameter" text
#     if( type(port_width) == str ):
#       self.width_pname = width
#       self.width = 0
#     else:
#       print("Error, Wire width should be int or string only")

  def get_conn_name(self):
    return(self.name)

  def get_conn_width(self):
    return(self.width)

  def set_src_inst(self, src_inst_name):
    self.src_isnt_name = src_inst_name

  def set_dst_inst(self, dst_inst_name):
    self.dst_isnt_name = dst_inst_name

  def set_src_port(self, src_port_name):
    self.src_port_name = src_port_name

  def set_dst_port(self, dst_port_name):
    self.dst_port_name = dst_port_name

# def upd_width(self, width):
#   self.upd_width(width)




# -------------------------------------------------------------------------------------------------------
# empty module with port only
class sub_module:
  def __init__(self, modu_name, inst_name):
    self.modu_name = modu_name
    self.inst_name = inst_name
    self.port_list = []
    self.para_list = []              # ["pADDR=10", "pDATA=32"]

# def set_inst_name(self, name):
#   self.inst_name = name

  def add_port(self, port_name):
  # check port_name duplicated or not)
  # print("add_port called: " + port_name)
    for prt in self.port_list:
     if( prt.name == port_name ):
       print("Error, same port name added: " + port_name + " on module: " + self.modu_name + " with instance: " + self.inst_name)
       sys.exit()

    new_port = port(port_name)
    self.port_list.append(new_port)
    return new_port

  # return True if already there
  def chk_port(self, port_name):
    # check port_name duplicated or not)
    for prt in self.port_list:
     if( prt.name == port_name ):
       return True

    return False

  # return port object
  def get_port(self, port_name):
    # check port_name duplicated or not)
    for prt in self.port_list:
     if( prt.name == port_name ):
       return prt

    return False
  

# def add_inst_cnt(self, name):
#   self.inst_cnt = name

  def add_caller(self, top_inst):
    self.caller_modu_name = top_inst 

  def add_comment(self, cmt_str):
    self.comment_str = cmt_str 
  
  def add_parameter(self, para_str):    # may contain one or more parameter setting
#   print(para_str)
    para_lst = para_str.split(",")
    for para in para_lst:
     para = re.sub("\s*", "",  para)
     # TBD
     # adjust pAAA     = Value string length
     # adjust pBBBBBB  = Value string length
   # print(para)
     self.para_list.append(para)

  def get_parameter(self):             # may contain one or more parameter setting
    return(self.para_list)

  def get_modu_name(self):
    return(self.modu_name)

  # print module parameter definition 
  def print_parm_def(self, fh):
    lcnt = len(self.para_list)
    lidx = 0
    mlen = len(self.modu_name)

    plen = 0
    for para in self.para_list:
      if( plen <= len(para) ):
        plen = len(para)
 
  # print(str(plen) + "," + str(mlen))
    mlen = plen
  # print(str(plen) + "," + str(mlen))

    if( lcnt > 0 ):
      for para in self.para_list:
        parm_name = re.sub('\s*\=.*', '', para)
        parm_valu = re.sub('.*\s*\=\s*', '', para)

        plen = len(parm_name)

        if( lidx < (lcnt-1) ):
          if( lidx == 0 ):
            print("parameter " + parm_name + spaces(mlen-plen) + "= " + parm_valu + ",", file=fh)
          else:
            out_str = "parameter " + parm_name + spaces(mlen-plen) + "= " + parm_valu + ","
          # out_str = out_str.rjust(mlen, ' ')
            print(spaces(len(self.modu_name) + 11) + out_str, file=fh)
        else:
          if( lidx == 0 ):
            print("parameter " + para      , file=fh)
          else:
            out_str = "parameter " + parm_name + spaces(mlen-plen) + "= " + parm_valu
          # out_str = out_str.rjust(mlen, ' ')
            print(spaces(len(self.modu_name) + 11) + out_str, file=fh)

          # print("parameter " + para      , file=fh)
        lidx +=1
    else:
      print(" ", file=fh)


  # print instance
  def print_parm_ist(self, fh):
    lcnt = len(self.para_list)
    mlen = len(self.modu_name)

    plen = 0
    for para in self.para_list:
      if( plen <= len(para) ):
        plen = len(para)

    mlen = plen + 4

    lidx = 0
    if( lcnt > 0 ):
      for para in self.para_list:
        parm_name = re.sub('\s*\=.*', '', para)
        parm_valu = re.sub('.*\s*\=\s*', '', para)

        plen = len(parm_name) + len(parm_valu) + 5

        if( lidx < (lcnt-1) ):
          if( lidx == 0 ):
            print("." + parm_name + "( " + parm_valu + " ),", file=fh)

          # print("parameter " + para + ",", file=fh)
          else:
            out_str = "." + parm_name + "( " + parm_valu + " ),"
          # out_str = out_str.rjust(mlen, ' ')
            print(spaces(len(self.modu_name) + 3) + out_str, file=fh)
        else:
          if( lidx == 0 ):                                                 # only one param
          # out_str = "." + parm_name + "( " + parm_valu + " )"
          # out_str = out_str.rjust(mlen, ' ')
          # print(out_str, file=fh, end='')
            print("." + parm_name + "( " + parm_valu + " )", file=fh, end='')
          else:                                                            # last param of multiple para
            out_str = "." + parm_name + spaces(mlen-plen) + "( " + parm_valu + " )"
          # out_str = out_str.rjust(mlen, ' ')
          # print(spaces(len(self.modu_name) + 3) + out_str + spaces(mlen-plen), file=fh, end='')
            print(spaces(len(self.modu_name) + 3) + out_str,                     file=fh, end='')

        lidx +=1

     #      out_str = "parameter " + para
     #      out_str = out_str.rjust(mlen, ' ')
     #      print(out_str, file=fh)

#       parm_name = re.sub('\s*\=.*', '', para)
#       parm_valu = re.sub('.*\s*\=\s*', '', para)
#       print("." + parm_name + "("+ parm_valu +"),", file=fh)
    else:
      print(" ", file=fh)

    print(") ", file=fh, end='')


  # module name and port list first (no code-body)
  def print_mod_hdr(self, fh):
    print_banner(fh)
    print("\n", file=fh)
    print("module " + self.modu_name + " ", file=fh, end='')
    if( len(self.para_list) > 0 ):
      print("#( ", file=fh, end='')
      self.print_parm_def(fh)

      out_str = ")"
      mlen = len(self.modu_name)
      mlen += 10
      out_str = out_str.rjust(mlen, ' ')
      print(out_str, file=fh)

    print("(", file=fh)
    # all in/out port
#   print("----")

    # get port width len(max)
    wlen = 0
#   print("====")
    for pt in self.port_list:
#    print(pt.name)
     if( wlen < len(pt.get_wid_str())):
#     print(pt.name + " " + pt.get_wid_str() + " = " + str(len(pt.get_wid_str())) )
      wlen = len(pt.get_wid_str())

    mlen = wlen + 1
    
#   print("----")
#   print(wlen)
#   print("----")

    pt_num = len(self.port_list)
    pt_cnt = 0
    for pt in self.port_list:
      if( pt_cnt == (pt_num -1) ):
        end_str = ""
      else:
        end_str = ","

    # print(pt.get_wid_str())
      wlen = len(pt.get_wid_str())
      if( pt.wid_is_num ):      # check width type (int or string)
        if( pt.width > 1 ):
          print("  " + pt.dir + " wire " + spaces(mlen-wlen) + pt.get_wid_str() + " " + pt.name + end_str, file=fh)
        else:
          print("  " + pt.dir + " wire " + spaces(mlen+1) + pt.name + end_str, file=fh)
      else:
        print("  " + pt.dir + " wire " + spaces(mlen-wlen) + pt.get_wid_str() + " " + pt.name + end_str, file=fh)
      pt_cnt += 1

#   print("----")

    print(");", file=fh)

  # null module
  def print_sub_def(self, fh):
   self.print_mod_hdr(fh)
   print("endmodule // " + self.modu_name, file=fh)

  # null module with output drive 0
  def print_dumy_io(self, fh):
   self.print_mod_hdr(fh)
   
   print("\n", file=fh)

   pn_len = 0                    # port name string length
   for pt in self.port_list:
     if( pn_len < len(pt.name) ):
       pn_len = len(pt.name)
    
   pm_len = pn_len + 1
  
   for pt in self.port_list:
     if( pt.dir == "output" ):
       pn_len = len(pt.name)
       if( pt.wid_is_num ):      # check width type (int or string)
         print("assign " + pt.name + spaces(pm_len-pn_len) + " = " + str(pt.width) + "'b0;", file=fh)
       else:
         print("assign " + pt.name + spaces(pm_len-pn_len) + " = " + "{"+ pt.width_pname + "{1'b0}};", file=fh)
   
   print("\n", file=fh)
   print("endmodule // " + self.modu_name, file=fh)

  def print_inst(self, fh):
    print_banner(fh)
    print("\n", file=fh)
#   print(self.modu_name + " #() " + self.inst_name + " (", file=fh)
    if( len(self.para_list) > 0 ):
      print(self.modu_name + " #(", file=fh, end='')
      self.print_parm_ist(fh)
    else:
      print(self.modu_name + "  ", file=fh, end='')

    print(self.inst_name + " (", file=fh)

    m_len = len(self.modu_name)
    i_len = len(self.inst_name)
    p_len = 0

    if( len(self.para_list) > 0 ):
      for para in self.para_list:
        if( p_len < len(para)):
          p_len = len(para)
    else:
      p_len = 0

    # all preceeding space length
    if( len(self.para_list) > 0 ):
      a_len = m_len + i_len + p_len + 11
    else:
      a_len = m_len + i_len + p_len + 4

    nlen = 0
#   print("====")
    for pt in self.port_list:
#     print(pt.name)
      if( nlen < len(pt.name)):
#       print(pt.name + " " + pt.get_wid_str() + " = " + str(len(pt.get_wid_str())) )
        nlen = len(pt.name)

    # max port name length
    mlen = nlen + 1

    pt_num = len(self.port_list)
    pt_cnt = 0
    for pt in self.port_list:
      if( pt_cnt == (pt_num -1) ):
        end_str = " "
      else:
        end_str = ","

      nlen = len(pt.name)
    # print(pt.get_wid_str())
      if( pt.wire_intf ):
        if( pt.dir == "output" ):
          dir = "O  " + pt.get_wid_str_simple()
        else:
          dir = "I  " + pt.get_wid_str_simple()
      else:
        dir = "INTF"

      ilen = len(pt.conn_name)
      ilen = 24 - ilen
      print(spaces(a_len) + "." + pt.name + spaces(mlen-nlen) + "(" + pt.conn_name + ")" + end_str + spaces(ilen) + "// " +  dir, file=fh)
      pt_cnt += 1

#   print("----")

    print(spaces(a_len-1) + ");", file=fh)





# -------------------------------------------------------------------------------------------------------
# module with inner wire and instance
class top_module(sub_module):
  def __init__(self, name):
    super().__init__(name, "")
    self.inst_dict   = {}          # key is inst_name, value is modu_name
    self.conn_list   = []
    self.smod_list   = []          # list of each sub-module instance
    self.smod_uniq   = []          # list of each sub-module instance count indicate it is the "uniq one" or "1'st one of many mulitple instance" when value is 1
    num_sub_modu     = 0

  def add_inst_name_dict(self, modu_name, inst_name):
    if( inst_name in self.inst_dict ):
      print("Error, same instance name: " + inst_name +" re-defined, module name is: " + modu_name)
      sys.exit()
    else:
      self.inst_dict[inst_name] = modu_name

  def add_sub_modu_inst(self, modu_inst):
    self.smod_list.append(modu_inst)

  def add_conn_wire(self, conn_name, width):
    conx = conn(conn_name)
    conx.set_conn_width(width)
    self.conn_list.append(conx)

  def chk_conn(self, conn_name):
    # get conn first
    for conx in self.conn_list:
      if( conx.get_conn_name() == conn_name ):
        return True
    return False



  # update width if wider
  def upd_conn_wire(self, conn_name, width):
    # get conn first
    if( width.isnumeric() ):       # check width string is pure number
      for conx in self.conn_list:
        if( conx.get_conn_name() == conn_name ):
        # print(width)
          conx.upd_width(width)
    else:
      print("Error, upd_conn_wire only support numerical width string")
      sys.exit()



#   conx = conn(conn_name)
#   conx.set_conn_width(width)
#   self.conn_list.append(conx)




  def add_conn_intf(self, intf_name, intf_inst):
    conx = conn(intf_inst)
    conx.set_conn_intf(intf_name)
    self.conn_list.append(conx)

  def get_sub_modu_by_inst(self, inst_name):
    found = False
    for subm in self.smod_list:
      if( subm.inst_name == inst_name ):
      # print("> " + subm.inst_name + " < " + inst_name)
        found = True
        break

    if found:
      return subm
    else:
      print("Error, cannot found instance: " + inst_name + " in current module: " + self.modu_name)
      print("List all current defined sub module instance")
      for subm in self.smod_list:
        print(subm.inst_name)
      sys.exit()

   
  def get_sub_modu_by_name(self, modu_name):
    for subm in self.smod_list:
      if( subm.modu_name == modu_name ):
        return subm

  def set_num_sub_modu(self, cnt):
    self.num_sub_modu = cnt

  def print_top_def(self, fh):
    self.print_mod_hdr(fh)

    print("\n", file=fh)

    # make beautful code
    w_len = 0
    for conn in self.conn_list:
      if( w_len < len(conn.get_wid_str())):
        w_len = len(conn.get_wid_str())
      
    m_len = w_len + 2  

    for conn in self.conn_list:
      w_len = len(conn.get_wid_str())
      print("wire " + spaces(m_len-w_len) + conn.get_wid_str() + " " + conn.get_conn_name() + ";", file=fh)

    print("\n", file=fh)
      
    # print all instance
    for subm in self.smod_list:
      subm.print_inst(fh)
      print("\n", file=fh)

    print("\n", file=fh)
   
    print("endmodule // " + self.modu_name, file=fh)

     
  def print_subm(self, target_modu):    # definition, instance, dummy_io
    idx=0
    trg_modu_found=0
    for subm in self.smod_list:
      fn = subm.modu_name
      if( self.smod_uniq[idx] < 2 and (fn == target_modu or target_modu == "") ):
        trg_modu_found=1
        fn = fn.lower() 
        fh = open(fn + ".vo", 'wt')
        subm.print_sub_def(fh)

        fh = open(fn + ".dummy_io.vd", 'wt')
        subm.print_dumy_io(fh)
      idx+=1

    # user specify the module name but not found
    if( target_modu != "" and trg_modu_found < 1):
      print("Cannot found -m module_name: " + target_modu)
      print("Please specify following valid module name:")
      for subm in self.smod_list:
       fn = subm.modu_name
       print(fn+", ")
      sys.exit()

    for subm in self.smod_list:
      mn = subm.modu_name
      if( target_modu == "" or mn == target_modu ):
        fn = subm.inst_name
        fn = fn.lower() 

        fh = open(fn + ".instance.vi", 'wt')
        subm.print_inst(fh)

   # fh = open(fn + ".dummy_io.vo", 'wt')
   # subm.print_dumy_io(fh)


# --------------------------------------------------------------------------------------------
# string format in XLS cell
# syntax:   modu_name : inst_name (comment)
def get_modu_name_cell(in_str):
# print(in_str)
  str0 = re.sub('\s*\(.*', '', in_str)       # remove comment
# str0 = "asdf"
# print(str0)
  modn = re.sub('\s*:\s*.*', '', str0)       # remove instance name if exists
  modn = re.sub('\s', '', modn)              # remove all space
  if( modn == "" ):
    print("Error, Null string detected, not a valid module name")
    sys.exit()
# print(modn)
  modn    = get_upper_str(modn)
  return(modn)


# string format in XLS cell
# syntax:   modu_name : inst_name (comment)
def get_inst_name_cell(in_str):
# print(in_str)
  str0 = re.sub('\s*\(.*', '', in_str)     # remove comment
  m = re.search(':', str0)
  if m:
    istn = re.sub('.*\s*:\s*', '', str0)  # remove module name
    istn = re.sub("\s*", "", istn)        # remove space
  else:
    modn = re.sub("\s*", "", str0)        # remove space
    istn = "U_" + modn + "0" 
# print(istn)

  istn= get_upper_str(istn)
  return(istn)
  




# return string. return "0" if is interface
# syntax src_port / dst_port : width (top_wire)
def get_port_width(port_str):
  m = re.search(':', port_str)
  if m:
    n = re.search('\.', port_str)    # system verilog interface
    if n:
      port_wid = "0"
    else:
      port_str = re.sub('.*:\s*', '', port_str)   # remove anything before ':', include :
      port_wid = re.sub('\s*\(.*','', port_str)   # remove anything after '('
    return(port_wid)
  else:
    return "1"


# return string
# syntax src_port / dst_port : width ( top_wire_name )
def get_port_src_name(port_str):
  port_str = re.sub('\s*:\s*.*', '', port_str)   # remove ':' and the rest
  port_str = re.sub('\s*\(.*', '', port_str)     # remove '(' and the rest
  m = re.search('\/', port_str)
  if m:
    port_src = re.sub('\s*\/.*', '', port_str)     # get src / .*
  else:
    port_src = re.sub('\s', '', port_str)
  return(port_src)



# m = re.search(':', port_str)
# if m:
#  port_str = re.sub('\s*:\s*.*', '', port_str)   # remove ':' and the rest
#  port_src = re.sub('\s*\/.*', '', port_str)     # get src / .*
#  return(port_src)
# else:
#  n = re.search('\.', port_str)   # system verilog interface
#  if n:
#   # TBD
#   n = re.sub('\s*\/\s*.*', '', port_str)
#   return n
#  else:
#   m = re.search('\/', port_str)
#   if m:
#     port_str = re.sub('\s*:\s*.*', '', port_str)    # remove ':' and the rest
#     port_dst = re.sub('\s*\/.*', '', port_str)
#   else:
#     port_dst = re.sub('\s', '', port_str)
#   return port_dst



# syntax src_port / dst_port : width ( top_wire_name )
def get_port_dst_name(port_str):
  port_str = re.sub('\s*:\s*.*', '', port_str)   # remove ':' and the rest
  port_str = re.sub('\s*\(.*', '', port_str)     # remove '(' and the rest
  m = re.search('\/', port_str)
  if m:
    port_dst = re.sub('.*\/\s*', '', port_str)     # get src / .*
  else:
    port_dst = re.sub('\s', '', port_str)
  return port_dst


# syntax src_port / dst_port : width ( top_wire_name )
# return top_wire
def get_port_top_conn(port_str):
  m = re.search('\.', port_str)
  if m:                                           
    # systemverilog port
    intf_con = re.sub('.*:\s*', '', port_str)     # remove anything before ":"
    top_conn  = re.sub('.*\.',  '', intf_con)     # remove anything before .
  else:                                           
    # generic wire
    m = re.search('\(', port_str)
    if m:
      intf_con = re.sub('.*:\s*',  '', port_str)     # remove anything before ":"
      top_conn  = re.sub('.*\(\s*','', intf_con)     # remove anything before ()
      top_conn  = re.sub('\s*\).*','', top_conn)     # remove anything before ()
    else:
      m = re.search('\/', port_str)
      if m:
        port_str = re.sub('\s*:\s*.*', '', port_str) # remove ':' and the rest
        port_str = re.sub('\s+',       '', port_str) # remove space
        top_conn = re.sub('\/',       '_', port_str) # replace \/ to '_'
      else:
        top_conn  = get_port_src_name(port_str)      # use simple port name as top-wire

  return top_conn


# return Intf_Name.Top_InterConn_Intf_Inst_Name (interface type and its instance name on top)
def get_port_intf_name(port_str):
  m = re.search('\.', port_str)
  if m:
    intf_name = re.sub('.*:\s*', '', port_str)     # remove anything before ".*:"
  else:
    intf_name = ""
  return intf_name






# return compact and consistent name => modn:inst
def get_modn_xlsx(in_str):
  modn_xlsx = re.sub('\s+',  '', in_str)
  modn_xlsx = re.sub('\(.*', '', modn_xlsx)
  return modn_xlsx




def build_top_module(work_sheet, top_modu):
# print(work_sheet.max_column)
# print(work_sheet.max_row)
# row_cnt = 1;
  modu_rowf = 0                  # flag means the start of module rows
  modu_ridx = 0                  # current module row index
  modu_cont = 0                  # total module count
  modu_nord = {}                 # key = coln index, value = module   name
  modu_iord = {}                 # key = coln index, value = instance name
  modu_vord = {}                 # key = coln index, value = full cell name (modu:inst) in XLS file
  modu_cord = {}                 # key = coln index, value = instance index, single or 1'st instance is 1, 2'nd of duplicated module is 2,   1, 1,2,3,4, 1
  modu_ndic = {}                 # key = module name, value is appearance count (instance count)

  # scan whole line(same row for each coln) to determined the postfix string of port name for module input and top wire name
  # "" <-- null for single instance
  # "_0" <-- for 1'st instance
  # "_1" <-- for 2'nd instance
  # "_2" <-- for 3'rd instance
  post_str  = []                 # "", "_0", "_1", "_2", "_3", ""

  for row in work_sheet:
#   print (row[0].value)
    if( row[0].value == "MODULES" ):
      modu_cont = len(row)-1
      print("Number of modules defined in this sheet: " + str(modu_cont))
      top_modu.set_num_sub_modu(modu_cont)
      ordi = 0;
      for cell in row:
        if( cell.value != "MODULES" ):
          if( str(cell.value) == "None" ):
#           print("--- " + str(cell.value) + " ---")
            break
#         else:
#           print("-- " + str(cell.value) + " --")

          modu_name = get_modu_name_cell(cell.value)
          inst_name = get_inst_name_cell(cell.value)
        # print("MODULES row: "+ inst_name + "," + modu_name + " == ", cell.value)

          sub_modu = sub_module(modu_name, inst_name)

          top_modu.add_sub_modu_inst(sub_modu)
          top_modu.add_inst_name_dict(modu_name, inst_name)
        # modn_xlsx = re.sub('\s+','',cell.value)
        # modu_vord[ordi] = re.sub('\(.*\)','', modn_xlsx)
          modu_vord[ordi] = get_modn_xlsx(cell.value)
          modu_nord[ordi] = modu_name
          modu_iord[ordi] = inst_name

          if( modu_name in modu_ndic ):
           modu_ndic[modu_name] += 1
          else:
           modu_ndic[modu_name] = 1

          modu_cord[ordi] = modu_ndic[modu_name]

          ordi+=1

      top_modu.smod_uniq = modu_cord # list of each sub-module instance with flag indicate it is the "uniq one" or "1'st one of many mulitple instance"

      # prepare post-fix string
      # scan the same row again
      ordi = 0;
      iidx = 0
      for cell in row:
        if( cell.value != "MODULES" ):
        # print("Index: " + str(ordi))
          modu_name = modu_nord[ordi]
        # print(modu_name)
          if( modu_ndic[modu_name] > 1 ):
            post_str.append("_" + str(iidx))
            iidx += 1
          else:
            post_str.append("")
            iidx = 0
          ordi+=1

      modu_rowf=1
      modu_ridx=0
      continue


    if( row[0].value == "PRI_PARAMETER" ):
      pri_param = row[1].value
      pri_param = re.sub("\s+\=", "=",  pri_param)    # change "  :" to ":"  leading
      pri_param = re.sub("\=\s+", "=",  pri_param)    # change ":  " to ":"  tailing
      pri_param = re.sub("[\s]+", ",",  pri_param)    # change all space to ","
      pri_param = re.sub("[,]+",  ",",  pri_param)    # reduce many ",,," to singe ","
      pri_param = re.sub(",$",    "",   pri_param)    # remove tail ',;
#     print(pri_param)
      top_modu.add_parameter(pri_param)     # may contain one or more parameter setting
      continue


    # ---------------------------------------------------------------------------------------------------------
    # start parsing inter-connect matrix
    # ---------------------------------------------------------------------------------------------------------
    if( modu_rowf > 0 and modu_ridx < modu_cont ):
      # check current row module exists or not
    # print("start parsing inter-connect matrix: " + str(modu_ridx))

    # print("----" + str(row[0].value) + "  " + str(row[1].value) + "----")
      row_xlsx = get_modn_xlsx(row[0].value)
    # if( modu_vord[modu_ridx] == row[0].value ):
    # print(row_xlsx)
      if( modu_vord[modu_ridx] == row_xlsx ):
      # print("Row-Col Matched")
        row_modn = get_modu_name_cell(row[0].value)                # input for module 
        row_istn = get_inst_name_cell(row[0].value)                # input for instce

      # print(row_modn + ":" + row_istn + " " + str(modu_ridx))
        row_modo = top_modu.get_sub_modu_by_inst(row_istn)        # module object
      # print(row_modo.modu_name + "::" + row_istn + "::" +  row_modo.inst_name)

        coln_idx = 0
        first_inst_in_col = 1
        for cell in row:
          port_str = str(cell.value)
          port_lst =[]
        # print(str(coln_idx) + "> "+ port_str + " <")
          if( coln_idx > 0 and port_str != "None" and (port_str != "NA" and port_str != "N/A") and row_modn != modu_nord[coln_idx-1] ):  # skip first colume (input module), skip empty, skip same module itself
            col_modo = top_modu.get_sub_modu_by_inst(modu_iord[coln_idx-1])        # module object
            # do something on port-list
            # port-list processing
            #  remove space " : " if have any first
            #  break into each port
            port_str = str(cell.value)
          # port_str = re.sub('\s+:', ':',  port_str)    # change "  :" to ":"  leading
          # port_str = re.sub(':\s+', ':',  port_str)    # change ":  " to ":"  tailing
            #  use "," or " " as port list delimitor
          # port_str = re.sub('\s+',  ',',  port_str)    # change all space to ","
          # port_str = re.sub('[,]+', ',',  port_str)    # reduce many ",,," to singe ","
          # port_str = re.sub(',$',   '',   port_str)    # remove last ,
          # print("ppp "+ port_str + " ppp")
          # port_lst = port_str.split(",")
            port_lst = get_port_list_from_cell(port_str)
#           print(port_lst)

            # check special pattern "<=" in port list string, if found, just skip curren colmun
            if( port_lst[0] == "<=" ):
              if( coln_idx <= 1 ):
                print("Err, special pattern \"<=\" is not allowed to appeat at first column")
                sys.exit()
              else:
                if( modu_ndic[col_modo.modu_name] > 1 ):
                  port_lst = pri_port_lst
                else:
                  print("Err, special pattern \"<=\" can only be used in multi-instance module")
                  sys.exit()

            # check col-module duplicated or not
            if( modu_ndic[col_modo.modu_name] > 1 ):
              if( first_inst_in_col > 0 ):
                # don't change the port_lst in current cell
                first_inst_in_col = 0
              else:
                # use the port_lst of left cell
                m = re.search('\/', port_lst[0])
                if m:
                  port_lst += ""      # do nothing
                else:
                  port_lst = pri_port_lst  # use left col cell string

            # ------------------------------------------------------------------------------
            # generic port name
            for port_n in port_lst:
                wid = get_port_width(port_n)      # wid is string
                sptn = get_port_src_name(port_n)
              # print(port_n + "==" + sptn)
                dptn = get_port_dst_name(port_n)
                conn = get_port_top_conn(port_n)
                conn += post_str[coln_idx-1]      # add empty "" or "_0", "_1"
                m = re.search('\/', port_n)
                if m:
                  dptn += ""  # do nothing
                else:
                  dptn += post_str[coln_idx-1]    # add post-fix
              # print(ptn)

                # ---------------------------------------------------------- 
                # add input-port to current row-module, add post_str if duplicated, check left column is the same module or not, if the same, then current column module output should skip
              # print("input  of row module: " + dptn)
              # print("row module inst: " + row_modo.inst_name + ", Port: " + dptn)
                ip = row_modo.add_port(dptn)
                if( wid != "0" ):
                  ip.is_wire("input ")
                  ip.set_width(wid)
                  # check col_modo output port defined yet
                  if( col_modo.chk_port(sptn) ):
                    # use its connection name
                    op = col_modo.get_port(sptn)
                    ip.set_conn_name(op.conn_name)
                  else:
                    ip.set_conn_name(conn)
                else:
                  print("Oops, Found Systemverilog Interface, not supported yet")
                  sys.exit()

                # ---------------------------------------------------------- 
                # add top wire
              # conn = get_port_top_conn(port_n)
              # conn += post_str[coln_idx-1]

              # if( top_modo.chk_port(sptn) ):       # same output port connect to multiple load, wire only need declared once
              #  top_modu.upd_conn_wire(conn, wid)   # widest width of top wire
              # else:
                if( not top_modu.chk_conn(conn) ):   # same output port connect to multiple load, wire only need declared once
                 top_modu.add_conn_wire(conn, wid)

                # ---------------------------------------------------------- 
                # add output-port to col-module if not add yet (only need add once for duplicated output port name)
             #  ptn = get_port_src_name(port_n)
             #  if( col_modo.chk_port(ptn) ):
             #    print("multi-fanout port: " + ptn + " of " + col_modo.modu_name)
             #  else:
                if( not col_modo.chk_port(sptn) ):
                # print("output of col module: " + ptn)
                  op = col_modo.add_port(sptn)      # no post-fix
                  if( wid != "0" ):
                    op.is_wire("output")
                    op.set_conn_name(conn)
                    op.set_width(wid)

           #  post_str[coln_idx]
           #  if( modu_ndic[modu_nord[coln_idx]] > 1 ):
           #  else:
              
          pri_port_lst = port_lst   # backup prior column port-list

          coln_idx+=1

        # finish all cell in a row

        # 1
        # check output module name duplicated in all column (same as left column's module) or equal to "<="
        # if found multiple instances (multiple input source from multile instance of same module), ie. same col-module scanned
        #   rename current port-name by add post-fix string  
        #   add renamed port to row-module input port, top-module wire list, add port(no post-fix) to colu-module output port
        # else (single module instance)
        #   add port to row-module input, add wire to top-module wire-list, add port to colu-module output (if not duplicated)


        # check special pattern "<=" in port list string, if found, just skip curren colmun

        # add top wire

#       col_idx = 0
#       for cell in row:
#         if( col_idx > 0 ):                              # skip first colume (input module)
#           if cell.value
#           top_modu.add_conn_wire()

#         col_idx+=1


        # add input port to current row module, check name duplicate case
#       col_idx=0
#       for cell in row:
#         if( col_idx > 0 ):
#           top_modu.add_conn_wire()

#         col_idx+=1



        # add output port to each column module
        # check left column is the same module or not, if the same, then current column module output should skip
#       col_idx=0
#       for cell in row:
#         if( col_idx > 0 ):

#         col_idx+=1
      else:
        print("Error, module mistmatch between row: " + str(modu_ridx) + " and column: " + modu_vord[modu_ridx] + " -- " + str(row[0].value))
#     continue

    if( modu_rowf > 0 ):
      modu_ridx+=1
#     continue

    if( modu_ridx == modu_cont ):
      modu_rowf = 0
#     continue

    # ------------------------------------------------------------------------------------------------
    if( row[0].value == "PRIMARY_INPUT" ):
    # print("PRIMARY_INPUT")
      coln_idx = 0
      for cell in row:
        port_str = str(cell.value)
      # if( coln_idx > 0 and port_str != "None" and modu_cord[coln_idx-1] < 2 ):                               # skip first colume (input module), skip empty
        if( coln_idx > 0 and port_str != "None"                               ):                               # skip first colume (input module), skip empty
        # port_str = re.sub('\s+:', ':',  port_str)    # change "  :" to ":"  leading
        # port_str = re.sub(':\s+', ':',  port_str)    # change ":  " to ":"  tailing
          #  use "," or " " as port list delimitor
        # port_str = re.sub('\s+',  ',',  port_str)    # change all space to ","
        # port_str = re.sub('[,]+', ',',  port_str)    # reduce many ",,," to singe ","
        # port_str = re.sub(',$',   '',   port_str)    # remove last ,
        # print("ppp "+ port_str + " ppp")
        # port_lst = port_str.split(",")
          port_lst = get_port_list_from_cell(port_str)

        # col_modo = top_modu.get_sub_modu_by_name(modu_nord[coln_idx-1])                                      # module object
          col_modo = top_modu.get_sub_modu_by_inst(modu_iord[coln_idx-1])                                      # module object

          for port_n in port_lst:
            wid = get_port_width(port_n)
            sptn = get_port_src_name(port_n)     # top-port
            dptn = get_port_dst_name(port_n)     # sub-module port
            conn = get_port_top_conn(port_n)     # sub-module port

            # add module port
            ip = col_modo.add_port(dptn)         # no post-fix
            if( wid != "0" ):
              ip.is_wire("input ")
              ip.set_width(wid)
              ip.set_conn_name(conn)


            if(not top_modu.chk_port(sptn)):    # new to top
              # add top port
              tp = top_modu.add_port(sptn)
              if( wid != "0" ):
                tp.is_wire("input ")
                tp.set_width(wid)
                tp.set_conn_name(conn)
            # allow same input port connect to multiple sub-modules

            # add top connection
            # comment out due to duplicated wire declaration
          # top_modu.add_conn_wire(conn, wid)

        coln_idx += 1
      continue


    # ------------------------------------------------------------------------------------------------
    if( row[0].value == "PRIMARY_OUTPUT" ):
    # print("PRIMARY_OUTPUT")
      coln_idx = 0
      for cell in row:
        port_str = str(cell.value)
      # if( coln_idx > 0 and port_str != "None" and modu_cord[coln_idx-1] < 2 ):                               # skip first colume (input module), skip empty
        if( coln_idx > 0 and port_str != "None"                               ):                               # skip first colume (input module), skip empty
        # port_str = re.sub('\s+:', ':',  port_str)    # change "  :" to ":"  leading
        # port_str = re.sub(':\s+', ':',  port_str)    # change ":  " to ":"  tailing
          #  use "," or " " as port list delimitor
        # port_str = re.sub('\s+',  ',',  port_str)    # change all space to ","
        # port_str = re.sub('[,]+', ',',  port_str)    # reduce many ",,," to singe ","
        # port_str = re.sub(',$',   '',   port_str)    # remove last ,
        # print("ppp "+ port_str + " ppp")
        # port_lst = port_str.split(",")
          port_lst = get_port_list_from_cell(port_str)

        # col_modo = top_modu.get_sub_modu_by_name(modu_nord[coln_idx-1])                                      # module object
          col_modo = top_modu.get_sub_modu_by_inst(modu_iord[coln_idx-1])                                      # module object

          for port_n in port_lst:
            wid = get_port_width(port_n)
            sptn = get_port_src_name(port_n)     # sub-module
            dptn = get_port_dst_name(port_n)     # top-port
            conn = get_port_top_conn(port_n)     # sub-module port

            # add module port
            op = col_modo.add_port(sptn)         # no post-fix
            if( wid != "0" ):
              op.is_wire("output")
              op.set_width(wid)
            # op.set_conn_name(conn)
              op.set_conn_name(dptn)

            # add top port
          # print("== " + dptn)
            tp = top_modu.add_port(dptn)
            if( wid != "0" ):
              tp.is_wire("output")
              tp.set_width(wid)
              tp.set_conn_name(conn)

            # add top connection, comment out due to duplicated wire declaration
          # top_modu.add_conn_wire(conn, wid)

        coln_idx += 1
      continue

    # ------------------------------------------------------------------------------------------------
    key_word = str(row[0].value)
    m = re.search('ADD_PRI_PORT', key_word)
    if m:

      port_n = re.sub('^\s*ADD_PRI_PORT\s*:\s*','', key_word)
    # print(port_n)
      wid = get_port_width(port_n)
      ptn = get_port_src_name(port_n)   # port name
      coln_idx = 0

      # add once for top
      tp = top_modu.add_port(ptn)
      tp.is_wire("input ")
      tp.set_width(wid)
      tp.set_conn_name(ptn)

      # add top connection
      # comment out due to duplicated wire declaration
    # top_modu.add_conn_wire(ptn, wid)

      for cell in row:
        port_str = str(cell.value)
      # if( coln_idx > 0 and port_str != "None" and modu_cord[coln_idx-1] < 2 and (cell.value == 'Y' or cell.value == 'y') ):   # skip first colume (input module), skip empty
        if( coln_idx > 0 and port_str != "None" and                               (cell.value == 'Y' or cell.value == 'y') ):   # skip first colume (input module), skip empty
          col_modo = top_modu.get_sub_modu_by_inst(modu_iord[coln_idx-1])                                      # module object
        # col_modo = top_modu.get_sub_modu_by_name(modu_nord[coln_idx-1])                                      # module object
        # wid = "1"

          ip = col_modo.add_port(ptn)         # no post-fix, add to each instacne
          ip.is_wire("input ")
          ip.set_width(wid)
          ip.set_conn_name(ptn)

        # tp = top_modu.add_port(ptn)
        # tp.is_wire("input ")
        # tp.set_width(wid)

          # add top connection
        # top_modu.add_conn_wire(conn, wid)

        coln_idx += 1

      continue

    # ------------------------------------------------------------------------------------------------
    key_word = str(row[0].value)
    m = re.search('ADD_MOD_PORT', key_word)
    if m:
      port_n = re.sub('^\s*ADD_MOD_PORT\s*:\s*','', key_word)
      wid = get_port_width(port_n)
      ptn = get_port_src_name(port_n)

    # print(ptn + " == " + wid)

      # add top connection
      top_modu.add_conn_wire(ptn, wid)

      coln_idx = 0
      for cell in row:
        dir_str = str(cell.value)
        dir_str = re.sub('\s*', '', dir_str)

      # if( coln_idx > 0 and port_str != "None" and modu_cord[coln_idx-1] < 2 ):                               # skip first colume (input module), skip empty
        if( coln_idx > 0 and dir_str != "None" ):
        # col_modo = top_modu.get_sub_modu_by_name(modu_nord[coln_idx-1])                                      # module object
          col_modo = top_modu.get_sub_modu_by_inst(modu_iord[coln_idx-1])                                      # module object
        # if( and modu_cord[coln_idx-1] < 2 ):                               # skip first colume (input module), skip empty
        #   col_modo = top_modu.get_sub_modu_by_name(modu_nord[coln_idx-1])                                      # module object
        #   wid = "1"

          xp = col_modo.add_port(ptn)         # no post-fix
          if( dir_str == 'I' or dir_str == 'i'):
            xp.is_wire("input ")
          else:
            if( dir_str == 'O' or dir_str == 'o'):
              xp.is_wire("output")
            else:
            # if( dir_str != '' and dir_str != "None" ):
              if( dir_str != '' ):
               print("Error, ADD_MOD_PORT only accept \'I\' or \'O\', Current Input is: " + dir_str)
               sys.exit()

          xp.set_width(wid)
          xp.set_conn_name(ptn)

        coln_idx += 1

      continue


    if( row[0].value == "SEC_PARAMETER" ):
      coln_idx = 0
      pri_param = ""
      for cell in row:
        parm_str = str(cell.value)
      # print(str(coln_idx) + "> "+ parm_str + " <")
      # if( coln_idx > 0 and parm_str != "None" and modu_cord[coln_idx-1] < 2 ):                               # skip first colume (input module), skip empty
        if( coln_idx > 0 and parm_str != "None" ):
        # col_inst_name = modu_iord[coln_idx-1]
          col_modo = top_modu.get_sub_modu_by_inst(modu_iord[coln_idx-1])                                      # module object
          if( modu_cord[coln_idx-1] < 2 ):                               # skip first colume (input module), skip empty
          # col_modo = top_modu.get_sub_modu_by_name(modu_nord[coln_idx-1])                                      # module object
          # do something on port-list
          # port-list processing
          #  remove space " : " if have any first
          #  break into each port
            sec_param = re.sub("\s+\=", "=",  parm_str)    # change "  :" to ":"  leading
            sec_param = re.sub("\=\s+", "=",  sec_param)    # change ":  " to ":"  tailing
            sec_param = re.sub("[\s]+", ",",  sec_param)    # change all space to ","
            sec_param = re.sub("[,]+",  ",",  sec_param)    # reduce many ",,," to singe ","
            sec_param = re.sub(",$",    "",   sec_param)    # remove tail ',;
            col_modo.add_parameter(sec_param)
            pri_param = sec_param
          else:
            col_modo.add_parameter(pri_param)

        coln_idx+=1

      continue



  

# print(pri_parameter)

# sys.exit()


# print(main_sheet.max_column)
# print(main_sheet.max_row)
# print(main_sheet.title)

# for row in main_sheet.iter_rows(min_row=1, max_col=7, values_only=True):
# for row in main_sheet.iter_rows(min_row=1, max_col=7):

# print("// This code snippet was auto generated by adrdec.py")
# td = today.strftime("%b-%d-%y")
# print("// Date:" + td +"\n")



# for row in main_sheet.iter_rows(max_col=6):
# for row in main_sheet.values(max_row=10):
# print(row,"\n")    
# print("\n")
# for ccc in row:
# print(ccc.value)
#   cell_a, cell_b, cell_c, cell_d, cell_e, cell_f = row
#   if(cell_a.value == "ADRBUS_NAME"):
#     adr_bus_name = cell_b.value

#   if(cell_a.value == "ADDRESS_UNIT"):
#     address_unit = cell_b.value

#   if(cell_a.value == "ADDRESS_MSB"):
#     address_msb  = cell_b.value

#   if(isinstance(cell_a.value, int)): 
#   print(cell_a.value)    
#     range_naml = cell_b.value.lower()
  # assume longest name is under 10
#     range_nams = range_naml.ljust(10, ' ')


# strlen = len(cell_b.value)
# print("wire adr_dec_" + range_name + " = " + adr_bus_name + "[" + (address_msb-1) + ":0]")
# adr_msb_str = str(address_msb-1)
# cpu_adr_nam = adr_bus_name + "[" + adr_msb_str + ":0]"

# size_str = cell_d.value
# size_str = size_str.ljust(7, ' ')


# low__addr   = cell_c.value
# low__addr   = str(address_msb) + "'h" + low__addr[2:]
  # remove '_'
# low__ints   = cell_c.value[:6] + cell_c.value[7:]
# low__int    = int(low__ints, 0)
# if low__int < pri_hi_adr:
#   print("Address Range Error, Current Low Address: " + low__addr + ", Prior High Address: " + high_addr)   
#   sys.exit()

# high_addr   = cell_e.value[:6] + '_' + cell_e.value[6:]
# high_addr   = str(address_msb) + "'h" + high_addr[2:]

# if( type(cell_f.value ) == str ):
#   cmt_str = cell_f.value
# else:
#   cmt_str = ""

# print("wire adr_dec_" + range_nams + " = (" + cpu_adr_nam + " >= " + low__addr + ") && (" + cpu_adr_nam + " < " + high_addr + ");   // Size: " + size_str +",  " + cmt_str )

# pri_hi_adr = int(cell_e.value, 0)

# print(adr_bus_name, address_unit, address_msb)





# --------------------------------------------------------------------------------------------------------------------------------------------
# --------------------------------------------------------------------------------------------------------------------------------------------

def main():
  parser = argparse.ArgumentParser(prog='xls2vlog.py', description='A verilog design integration tool',epilog="  Author: Unnamed RnD, Taiwan")

  parser.add_argument("-i", "--input_file",  nargs=1, required=True,  type=str,                                      help="source .xlsx file for input")
  parser.add_argument("-s", "--sheet_name",  nargs=1, required=False, type=str,  default="",                         help="target worksheet name for code generation")

  parser.add_argument("-o", "--output_file", nargs=1, required=False, type=str,  default="",                         help="filename of generated top module file")

  parser.add_argument("-m", "--module",      nargs=1, required=False, type=str,  default="",                         help="specify which sub-module will be generated, not all sub-modules")

  parser.add_argument("-modu_lowercase",              required=False,            default=False, action="store_true", help="force lowercase in module name of generated verilog module")
  parser.add_argument("-modu_uppercase",              required=False,            default=True,  action="store_true", help="force uppercase in module name of generated verilog module")
  parser.add_argument("-modu_no_underscore",          required=False,            default=False, action="store_true", help="Remove underscore character in module name of generated verilog module")

  parser.add_argument("-port_lowercase",              required=False,            default=False, action="store_true", help="force lowercase in module name of generated verilog module")
  parser.add_argument("-port_uppercase",              required=False,            default=True,  action="store_true", help="force uppercase in module name of generated verilog module")
  parser.add_argument("-port_keepcase",               required=False,            default=False, action="store_true", help="Remove underscore character in module name of generated verilog module")

  parser.add_argument("-modi_prefix",        nargs=1, required=False, type=str,  default="U_",                       help="add prefix to instance name of sub-module in the generated top module file")
  parser.add_argument("-modi_lowercase",              required=False,            default=True,  action="store_true", help="force lowercase to the instance name")
  parser.add_argument("-modi_uppercase",              required=False,            default=False, action="store_true", help="force uppercase to the instance name")

  args = parser.parse_args()

  if( args.modu_lowercase ):
   args.modu_uppercase = False;

  if( args.port_lowercase ):
    args.port_uppercase = False;
    args.port_keepcase  = False;
  else:
    if( args.port_keepcase ):
      args.port_lowercase = False;
      args.port_uppercase = False;


  xlsx_fn = args.input_file[0]
  if( not os.path.isfile(xlsx_fn) ):
    print("File: " + xlsx_fn + " doesn't exists")
    sys.exit()

  global src_file
  src_file = xlsx_fn

  from openpyxl       import Workbook,load_workbook
  from openpyxl.utils import get_column_letter,column_index_from_string

  wb = load_workbook(xlsx_fn, data_only=True)

  vlog_fn = args.output_file
  sheet_n = args.sheet_name

  use_xls_sheet_name = 0
  if( vlog_fn == "" ):
   use_xls_sheet_name = 1

  global prt_modu
  prt_modu=args.module   # a list
  # change to string
  if(prt_modu == ""):
    prt_modu = ""
  else:
    prt_modu = prt_modu[0]
    print("-m option specified. Only module: " + prt_modu + " will be generated")

# else:
#  vlog_fn = vlog_fn[0]
# print(vlog_fn)
   
  num_of_shet = len(wb.sheetnames) 
  cur_sheet = ""

# list all sheets in the workbook
  for sheetnm in wb.sheetnames:
    if( sheetnm != "README" and (sheet_n == "" or sheet_n[0] == sheetnm )):
      cur_sheet = wb[sheetnm];
  #   sheet_name = cur_sheet.title;
  #   print(sheetnm)
      cur_top_modn = get_upper_str(sheetnm)
      print("Current Sheet Name: " + sheetnm + ", Generate Top Module: " + cur_top_modn)
  #   print(cur_out_modn)
  #   create a top module instance
      top_modu = top_module(cur_top_modn)
      build_top_module(cur_sheet, top_modu)

      if( use_xls_sheet_name ):
        vlog_fn = cur_top_modn
      else:
        if( num_of_shet > 2 ):
          print("-o option was specified but more than two sheet found in .XLSX file")
          sys.exit()
        else:
         vlog_fn = vlog_fn[0]

      # change file name to lower case
      vlog_fn = vlog_fn.lower() 

      print("Create a sub-directory for file output: ", vlog_fn)
      if( not os.path.exists(vlog_fn) ):
        os.mkdir(vlog_fn)
      os.chdir(vlog_fn)
     
      if(prt_modu == ""):
        top_fh = open(vlog_fn + ".vo", 'wt')
        top_modu.print_top_def(top_fh)  # definition

      if(prt_modu == ""):
        top_fh = open(vlog_fn + ".instance.vi", 'wt')
        top_modu.print_inst(top_fh)     # instance of top

      top_modu.print_subm(prt_modu)     # definition, instance, dummy_io

  if( cur_sheet == "" ):
    if( sheet_n == "" ):
      print("No -s specified and no valid sheet detected")
    else:
      print("Cannot find sheet: " + sheet_n[0] + " in: ")
      for sheetnm in wb.sheetnames:
       print(sheetnm + ", ",end='')
      print("")
      sys.exit()


if __name__ == "__main__":
  main()
